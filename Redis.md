根据[小林 Coding](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxODAzNDg4NQ==&action=getalbum&album_id=1790401816640225283#wechat_redirect) 整理的 Redis 八股，主要是起到大纲的作用。

## 一、缓存异常

> reference: 
>
> * [再也不怕，缓存雪崩、击穿、穿透！](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247490008&idx=1&sn=8f576e69ec63e02a8b42a00ae6754f0a&chksm=f98e5d72cef9d464710c891c4c0537c20e4949b39ee70c97c44c3f6f95df83fc406f52fc161b&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

缓存雪崩、缓存击穿、缓存穿透

* 概念
* 解决方案

## 二、Redis 持久化

> reference: 
>
> * [宕机了，缓存数据没了。。。](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247493808&idx=1&sn=588d318ec6e72844841d566f16acaf30&chksm=f98dac1acefa250ce40060899a4030bb7678c45befea408162360db4ef4fa2785feb1544e719&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)
> * [咔擦，不就是快照嘛](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247494677&idx=1&sn=53f60870b66c731aa6ec5b6e70697eff&chksm=f98da8bfcefa21a9ad7b4d564238931f8457bafb08698301e9672dbc366a034890429fdc1ff1&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

Redis 虽然是内存数据库，但是也可以持久化存储：

* AOF（Append only File）
* RDB（Redis DataBase）

在 RDB 中，

## 三、单线程

> reference：
>
> * [快问快答！](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247495027&idx=1&sn=217af306b07ed0f2a064773541d46721&chksm=f98da9d9cefa20cf7ce2ef0ebf60cf378b79958a2e34559c9da7922be4a946a800ff815f950f&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

Redis 确实是以单线程架构被大家所知，但是这个单线程指的是「**从网络 IO 处理到实际的读写命令处理**」都是由单个线程完成的，并不是说整个 Redis 里只有一个主线程。

有些命令操作可以用后台子进程执行（比如快照生成、AOF 重写）。

严格意义上说的话，Redis 4.0 之后并不是单线程架构了，除了主线程外，它也有后台线程在处理一些耗时比较长的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。

你可能听到 Redis 6.0 版本支持了多线程技术，不过这个并不是指多个线程同时在处理读写命令，而是使用多线程来处理 Socket 的读写，**最终执行读写命令的过程还是只在主线程里**。

之所以采用多线程 IO 是因为Redis 处理请求时，网络处理经常是瓶颈，通过多个 IO 线程并行处理网络操作，可以提升整体处理性能。

那为什么处理操作命令的过程只在单线程里呢？

因为 Redis 不存在 CPU 成为瓶颈的情况，**主要受限于内存和网络**。

而且使用单线程的好处在于，可维护性高、实现简单。

如果采用多线程模型来处理读写命令，虽然能提升并发性能，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。

## 四、主从复制

> reference：
>
> * [小林差点崩溃了，还好有主从复制](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247495237&idx=1&sn=8302585810958567a57bda3df6c5d036&chksm=f98daaefcefa23f95e9f4ef083bbf6b8ce80794bb00c68d9070f158e6de9a0265ea39b12e560&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

主从复制模式可以保证多态服务器的数据一致性，且主从服务器之间采用的是 **读写分离** 的方式。

主从复制的三种写命令传播模式：

1. 全量复制
2. 基于长 TCO 连接的命令传播
3. 增量复制

主从服务器第一次同步的时候，就是采用全量复制，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。

第一次同步完成后，主从服务器都会维护着一个长连接，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。

如果遇到网络断开，增量复制就可以上场了，不过这个还跟 `repl_backlog_size `这个大小有关系。

如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。

## 五、三种缓存更新策略

> reference：
>
> * [面试官：3 种缓存更新策略是怎样的？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247516371&idx=2&sn=1976ef550b5b0a1d52f7ca09ec9d5d80&chksm=f98dc479cefa4d6fd74412c99f12b21ed3cee4b8e74c005710ce5bc575d0832e96e6184126c5&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

对于每一种策略，在读模式或写模式下是怎样的？在读模式下，主要考虑的是数据不在缓存时，由谁加载数据？

1.Cache Aside（旁路缓存）策略

* 应用程序与缓存和数据库交互

* Cache Aside 需要先写入数据库，再删除缓存，而不能先删除缓存，再更新数据库

* 对于先删除缓存，再写入数据库导致的数据不一致，可以使用延迟双删策略：

  ``` shell
  #删除缓存
  redis.delKey(X)
  #更新数据库
  db.update(X)
  #睡眠
  Thread.sleep(N)
  #再删除缓存
  redis.delKey(X)
  ```

  加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。

  所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。

  但是具体睡眠多久其实是个**玄学**，很难评估出来，所以这个方案也只是**尽可能**保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。

  因此，还是比较建议用「先更新数据库，再删除缓存」的方案。

2.Read/Write Through（读穿/写穿）策略

* 应用程序与缓存交互，缓存和数据库交互
* 搭配写不分配
* 相较于 Cache Aside 比较少见，因为例如 Redis 等内存数据库都不提供写入数据库和自动加载数据库中的数据的能力

3.Write Back（写回）策略

* 应用程序与缓存交互，缓存和数据库交互
* 搭配写分配
* 对于脏数据的刷盘，缓存会通过批量异步更新的方式进行
* 和 Write Through 一样，Write Back 也很少应用到数据库和缓存的场景中，因为 Redis 没有异步更新数据库的能力

## 六、数据库和缓存如何保持一致性

> reference:
>
> * [老板真爱画大饼！](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247497782&idx=1&sn=89fd676bbe63a819ad1e32976a0755ee&chksm=f98dbc9ccefa358ab0379e4e7799f53668cb31d401ed329658d05e9aea83949a6898b46279e5&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)
> * [趣说 ｜ 数据库和缓存如何保证一致性？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247508038&idx=2&sn=50a5d4a4b88f9572976753562aeb1b52&chksm=f98de4eccefa6dfaf9c48451685b51a7be62f237cb5ab13efb75a83b814437a370b2f8abfa88&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

### 1. 先更新数据库，还是先更新缓存？

注意这里是更新缓存而不是删除缓存，不同于 Cache Aside，这里无论是先更新数据库，还是先更新缓存，都会出现并发问题。

* 考虑两条并发执行的指令，分别将 val 的值设置为 1,2，由于指令的交叉执行，无论先更新数据库还是先更新缓存，都会出现并发问题。

如何解决该问题，参考 Cache Aside，修改更新缓存操作为删除缓存，就可以保证数据的一致性。

此外，为了万无一失，还可以给数据加上过期时间，这样即使缓存数据不一致，也有过期时间来兜底，不会造成太大影响。

不过，虽然 Cache Aside 有效解决了一致性问题，但是它粗暴的删除缓存会导致缓存命中率下降，特别是业务是写多读少的情况，对性能的影响比较大。

如果我们不能接受缓存的频繁 miss，只能是更新缓存而不是删除缓存，此时为了保证数据库和缓存的一致性，有以下两种解决方案：

1. 在更新缓存前加个分布式锁，但是锁会影响 redis 的访问。
2. 在更新完缓存之后，加上一个较短的过期时间，降低数据不一致时的损失。

### 2. 删除缓存的时候失败了

在先更新数据库再删除缓存的方案中，如果在删除缓存的时候失败了，导致缓存中的数据依然是旧值怎么办？

有以下两种方案：

* 重试机制

  我们可以引入**消息队列**，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。

  - 如果应用**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
  - 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。

* 订阅 Mysql binlog，再操作缓存

  「**先更新数据库，再删缓存**」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。

  于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。

所以，如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用 **异步操作** 缓存。

## 七、过期删除策略

每当我们对一个 key 设置了过期时间时，Redis  会把该 key 带上过期时间存储到一个**过期字典**（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。

当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：

- 如果不在，则正常读取键值；
- 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。

常见的三种过期删除策略：

- 定时删除：cpu 不友好，内存友好
- 惰性删除：cpu 友好，内存不友好
- 定期删除：折中吗。**每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。**

前面介绍了三种过期删除策略，每一种都有优缺点，仅使用某一个策略都不能满足实际需求。

所以， **Redis 选择「惰性删除+定期删除」这两种策略配和使用**，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

## 八、内存淘汰策略

前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。

在配置文件 `redis.conf` 中，可以通过参数 `maxmemory <bytes>` 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。

不同位数的操作系统，maxmemory 的默认值是不同的：

- 在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。
- 在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。

Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。其中，「进行数据淘汰」又分为 「只淘汰过期数据」和「可以淘汰任意数据」。

***1、不进行数据淘汰的策略***

* **noeviction**（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。

***2、进行数据淘汰的策略***

针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。

***2.1、在设置了过期时间的数据中进行淘汰：***

- **volatile-random**：随机淘汰设置了过期时间的任意键值；
- **volatile-ttl**：优先淘汰更早过期的键值。
- **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
- **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用频率的键值；

***2.2、在所有数据范围内进行淘汰：***

- **allkeys-random**：随机淘汰任意键值;
- **allkeys-lru**：淘汰整个键值中最久未使用的键值；
- **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

---

值得注意的是，Redis 实现的并不是传统的基于链表的 LRU，因为传统的 LRU 算法存在两个问题：

1. 需要用链表管理所有的缓存数据，这会带来额外的空间开销；
2. 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。

Redis 实现的是一种**近似 LRU 算法**，目的是为了更好的节约内存，它的**实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间**。

当 Redis 进行内存淘汰时，会使用**随机采样的方式来淘汰数据**，它是随机取 5 个值（此值可配置），然后**淘汰最久没有使用的那个**。

Redis 实现的 LRU 算法的优点：

- 不用为所有的数据维护一个大链表，节省了空间占用；
- 不用在每次数据访问时都移动链表项，提升了缓存的性能；

但是 LRU 算法有一个问题，**无法解决缓存污染问题**，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。

因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。

LFU 全称是 Least Frequently Used 翻译为**最近最不常用的，**LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。

所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。

LFU 算法相比于  LRU 算法的实现，多记录了「数据的访问频次」的信息。



## 为什么 Redis 要有哨兵

> reference:
>
> * [面试官：为什么 Redis 要有哨兵？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247515688&idx=2&sn=9680569edd01c327253c7eb87a75ab94&chksm=f98dfa82cefa73943fa320a1debda7c7d461c675a41cbf4c9808009f6c082588ab194344f4f0&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

Redis 对象的结构如下：

```cpp
typedef struct redisObject {
    ...
      
    // 24 bits，用于记录对象的访问信息
    unsigned lru:24;  
    ...
} robj;
```

Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。

在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。

在 LFU 算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。

- ldt 是用来记录 key 的访问时间戳；
- logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。

注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 **logc  会随时间推移而衰减的**。

在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据**访问频率**来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。

对 logc 做完衰减操作后，就开始对 logc  进行增加操作，增加操作并不是单纯直接 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。

所以，Redis 在访问 key 时，对于 logc  是这样变化的：

1. 先按照上次访问距离当前的时长，来对 logc 进行衰减；
2. 然后，再按照一定概率增加 logc 的值

redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：

- `lfu-decay-time` 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time 值越大，衰减越慢；
- `lfu-log-factor` 用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。

## 九、你确定 Redis 是单线程的进程吗

> reference:
>
> * [为什么单线程的 Redis 如何做到每秒数万 QPS ？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247511819&idx=2&sn=b6c533071625d9f11c019f8a6c0f1b63&scene=21#wechat_redirect)
> * [面试官：你确定 Redis 是单线程的进程吗？](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247516338&idx=2&sn=481c0c5ba605eddbc4824056d941a261&chksm=f98dc418cefa4d0ec4e8e3e2a1c1badc6cb66b5c20775ff785b8ef0da708cf8eb0a1c42c236f&scene=178&cur_album_id=1790401816640225283&search_click_id=#rd)

### 1. Redis 是单线程吗

**Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发生数据给客户端」这个过程是由一个线程（主线程）来完成的**，这也是我们常说 Redis 是单线程的原因。

这种单线程模型，结合高效的  **I/O 多路复用机制**（如 epoll/kqueue），使得 Redis 能够避免多线程带来的上下文切换和锁竞争开销，尤其对于其内存中的数据结构操作，能实现非常高的性能。

但是，**Redis 程序并不是单线程的**，Redis 在启动的时候，是会**启动后台线程（BIO）**的：

- **Redis 在 2.6 版本**，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；
- **Redis 在 4.0 版本之后**，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。

之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。

后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。

关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：

- BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；
- BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，
- BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；

### 2. Redis 单线程模式是怎样的

Redis 6.0 版本之前的单线模式如下图：

![redis_single_thread_before_v6.0](https://github.com/QaQOwOQaQ/picx-images-hosting/raw/master/image.8adihgi3ru.png)

### 3. Redis 采用单线程为什么还这么快

官方使用基准测试的结果是，**单线程的 Redis 吞吐量可以达到 10W/每秒**。

之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：

- Redis 的大部分操作**都在内存中完成**，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以**避免了多线程之间的竞争**，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
- Redis 采用了 **I/O 多路复用机制**处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

### 4. Redis 6.0 之前为什么使用单线程

我们都知道单线程的程序是无法利用服务器的多核 CPU 的，那么早期 Redis 版本的主要工作（网络 I/O 和执行命令）为什么还要使用单线程呢？我们不妨先看一下Redis官方给出的FAQ。

![why_single_thread_before_v6.0](https://github.com/QaQOwOQaQ/picx-images-hosting/raw/master/image.51eekt0lh8.webp)

核心意思是：**CPU 并不是制约 Redis 性能表现的瓶颈所在**，更多情况下是受到内存大小和网络I/O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。

除了上面的官方回答，选择单线程的原因也有下面的考虑。

使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，**增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗**。

### 5. Redis 6.0 之后为什么引入了多线程?

虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在 **网络 I/O 的处理** 上。

> 在 Redis 的语境中，**网络 I/O (Input/Output)** 主要指以下两个核心环节：
>
> 1. **从客户端读取数据 (Input)：**
>    - **接收原始字节流：** 当客户端向 Redis 发送命令时，数据通过网络传输到达 Redis 服务器。这涉及底层的 TCP/IP 协议栈，Redis 需要从操作系统的网络缓冲区中读取这些原始字节。
>    - **协议解析：** 读取到的原始字节流是按照 Redis 自己的通信协议 (RESP, Redis Serialization Protocol) 进行编码的。Redis 需要解析这些字节流，将其还原成客户端发送的命令（例如 `SET key value`、`GET key` 等），并提取出命令参数。
> 2. **向客户端写入数据 (Output)：**
>    - **构建响应：** 在 Redis 主线程执行完命令（例如 `GET key` 后获取到 `value`）之后，它需要将结果按照 RESP 协议编码成字节流。
>    - **发送数据到网络：** 编码好的字节流需要通过网络发送回客户端。这同样涉及底层的 TCP/IP 协议栈，Redis 需要将这些数据写入操作系统的网络缓冲区，最终通过网络传输到客户端。
>
> **在 Redis 6.0 之前，这两个过程（读取、解析、构建响应、写入）都是由唯一的“主线程”来完成的。** 尽管 Redis 使用了 **I/O 多路复用** (如 epoll/kqueue) 技术来高效地监听多个客户端连接的读写事件，避免了阻塞，但当某个连接有数据可读或可写时，具体的读写和协议解析工作仍然由主线程亲自完成。
>
> **Redis 6.0 引入多线程后，这里的“网络 I/O”具体是指将上述步骤中的：**
>
> - **从客户端读取原始字节流**
> - **对读取到的原始字节流进行协议解析**
> - **将执行结果编码成字节流**
> - **将编码后的字节流写入网络**
>
> 这部分**耗时的网络数据处理和协议编解码工作**，从主线程中剥离出来，交由多个 **I/O 线程**（通常配置为 `io-threads` 数量）来并行处理。
>
> **职责划分大致如下：**
>
> - **主线程 (Main Thread):**
>   - 负责监听客户端连接的接入（`accept`）。
>   - **核心命令的执行：** 所有的 Redis 命令（如 `GET`、`SET`、`LPUSH` 等）仍然由主线程串行执行，这保证了 Redis 单命令操作的原子性。
>   - 将解析好的命令放入执行队列。
>   - 从 I/O 线程获取命令执行结果，并准备待写入的数据。
> - **I/O 线程 (IO Threads):**
>   - **并行读取客户端数据：** 从网络 socket 中读取原始字节流。
>   - **并行解析客户端命令：** 将读取到的字节流按照 RESP 协议解析成 Redis 命令结构。
>   - **并行编码响应数据：** 将主线程执行后的结果，编码成 RESP 协议的字节流。
>   - **并行写入响应数据：** 将编码好的字节流写入到网络 socket，发送回客户端。
>
> 通过这种方式，Redis 6.0 的多线程 I/O 模块有效地将网络 I/O 的阻塞和计算密集型任务（协议解析和编码）分散到多个 CPU 核上，从而减少了主线程在这些任务上的等待时间，显著提升了在高并发网络流量下的吞吐量。

所以为了提高网络请求处理的并行度，Redis 6.0 对于网络请求采用多线程来处理。**但是对于命令执行，Redis 仍然使用单线程来处理，**所以大家**不要误解** Redis 有多线程同时执行命令。

Redis 官方表示，**Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上**。

Redis 6.0 版本支持的 I/O  多线程特性，默认是 I/O 多线程只处理写操作（write client socket），并不会以多线程的方式处理读操作（read client socket）。要想开启多线程处理客户端读请求，就需要把  Redis.conf  配置文件中的 io-threads-do-reads 配置项设为 yes。

```
//读请求也使用io多线程
io-threads-do-reads yes 
```

同时， Redis.conf  配置文件中提供了  IO 多线程个数的配置项。

```
// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）
io-threads 4 
```

关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。因此， **Redis 6.0 版本之后，**Redis 在启动的时候，默认情况下会有 6 个线程：

- Redis-server ：Redis的主线程，主要负责执行命令；
- bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；
- io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。





































































































































