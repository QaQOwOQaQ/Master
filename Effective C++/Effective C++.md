# English

* pseudo
* overhead
* native
* modifier
* directive
* hierarchy
* handle
* encapusulation
* equality
* equivalence
* address-of operator
* 

# Preface

### 1. object oriented 的翻译

为什么说 object"在  Object  Oriented  技术中的真正意义是“物体、物件”而非“对象、目标”。 

这确实是一个很有意思的视角，它强调了 "object" 在面向对象技术中与现实世界概念的紧密联系。之所以说 "object" 的真正意义更接近于 "物体、物件" 而非 "对象、目标"，主要是因为它强调了 **封装的数据和行为的实体性**。

让我们展开来说说：

**1. "物体、物件" 强调的是实体和属性：**

- 当我们说 "物体" 或 "物件" 时，我们通常指的是现实世界中可以触摸、感知，或者至少可以概念化为一个独立存在的实体。比如，一辆汽车、一棵树、一本书、一个灯泡等等。
- 这些 "物体" 都具有自身的 **属性 (properties/attributes)**，例如汽车的颜色、型号、速度；树的高度、种类、叶子形状；书的页数、作者、书名；灯泡的功率、颜色、亮度等等。
- 在面向对象编程中，一个 "object" 同样拥有 **数据 (data)**，这些数据就代表了 "物体" 的属性。

**2. "物体、物件" 强调的是行为和功能：**

- 现实世界中的 "物体" 不仅仅是静态的属性集合，它们还具有 **行为 (behavior/function)**。汽车可以行驶、刹车；树可以生长、落叶；书可以被阅读；灯泡可以发光、熄灭。
- 在面向对象编程中，一个 "object" 也包含 **方法 (methods)**，这些方法定义了 "物体" 所能执行的操作或功能。

**3. "对象、目标" 更偏向于关系和指代：**

- 当我们说 "对象" 或 "目标" 时，更多的是在描述一种关系或者一个动作指向的对象。比如，"研究对象"、"攻击目标"、"关注的对象" 等等。
- 虽然在编程中我们也经常使用 "对象" 来指代实例化的类，但这个词的重心更多在于它是某个操作或交互的承受者或参与者，而较少强调其内在的实体性和自包含性。

**4. 面向对象的核心思想是模拟现实世界：**

- 面向对象编程的一个核心思想就是通过软件来模拟现实世界中的实体及其相互作用。将现实世界中的 "物体" 抽象成程序中的 "object"，能够更好地理解和组织复杂的系统。
- 通过将数据（属性）和行为（方法）封装在一个 "object" 内部，我们能够更好地实现模块化、信息隐藏和代码重用，这与我们理解现实世界中独立存在的 "物体" 是类似的。

**总结来说：**

虽然在中文语境下 "对象" 已经成为 "object" 在编程领域的常用翻译，但从面向对象技术的核心理念和 "object" 本身的含义来看，将其理解为更具实体性的 "物体" 或 "物件" 能更好地体现其 **数据和行为的封装性以及与现实世界实体的对应关系**。这种理解有助于我们更深入地把握面向对象编程的本质。

当然，语言的使用是约定俗成的，"对象" 这个翻译已经被广泛接受。我们只是从一个更细致的角度来探讨 "object" 这个词在技术语境下的深层含义。

# 一、让自己习惯 C++

## Q1. 视 C++ 为一个语言联邦

* C
* Object-Oriented C++
* Template C++
* STL

C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分。

例如 C 部分的内置类型`char`、`int`、`double`、`pointer` **pass-by-value** 比 **pass-by-reference** 更高效；但在 Object-Oriented 的部分，**pass-by-const reference** 一般是更高效的方式。

## Q2. 尽量以 const, enum, inline 替换 macro

其核心思想在于，用 **编译器** 代替 **预处理器**。

### 1. `#define`

请注意，我们无法利用 `#define` 创建一个 class 专属常量，因为 `#define` 并不重视作用域 (scope) 。一旦宏被定义，它就在其后的编译过程中有效（除非在某处被 `#undef`) 。这意味` #define` 不仅不能够用来定义 class 专属常量，也不能够提供任何封装性，也就是说没有所谓 `private #define` 这样的东西。

``` cpp
class Foo {
public:
    #define N 10
};

int main()
{
    cout << N << endl; // 10
    return 0;
}
```

### 2. `enum`

``` cpp
class Foo {
public:
    enum Color { RED, BLUE, GREEN };
};

int main()
{
    cout << sizeof(Foo) << endl; // 1
    // cout << &Foo::RED << endl; // error: lvalue required as unary '&' operand
    return 0;
}
```

首先，类中的 `enum` 是作为 **类型成员** 存在的，它不占用类的内存空间。

其次，我们不能对枚举常量取地址，因为枚举属于**字面值**常量类型。

## Q3. 尽可能使用 const

### 1. 一个容易犯的错误

``` cpp
struct Number { int val; };

Number operator*(const Number &x, const Number &y) {
    return Number{x.val * y.val};
}

int main()
{
    Number a{1}, b{2}, c{3};
    a * b = c; // 不推荐但可以通过编译
    return 0;
}
```



## Q4. 确定对象被使用前已被初始化

这里的使用包括赋值。

虽然推荐直接在初始值列表中初始化，但对于那些具有多个构造函数，并且构造过程比较类似的类，可以将构造过程提取为一个 `private` 方法，然后在构造函数体内调用这个方法，从而避免代码的重复。



# 二、构造/析构/赋值运算

## Q5: 了解 C++ 默认编写并调用哪些函数

## Q6：若不想使用编译器自动生成的函数，就应该明确拒绝

























































































































































































































































































































